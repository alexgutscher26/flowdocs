
generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
}

model User {
  id            String     @id
  email         String     @unique
  name          String?
  role          UserRole   @default(user)
  status        UserStatus @default(ACTIVE)
  emailVerified Boolean    @default(false)
  image         String?
  phone         String?
  lastLoginAt   DateTime?
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @default(now()) @updatedAt

  // Onboarding fields
  onboardingCompleted Boolean @default(false)
  onboardingData      Json?

  // Admin plugin fields
  banned        Boolean?
  banReason     String?
  banExpires    DateTime?

  // Relations
  sessions      Session[]
  accounts      Account[]
  workspaces    WorkspaceMember[]
  invitationsSent WorkspaceInvitation[]

  // Default workspace
  defaultWorkspaceId String?
  defaultWorkspace   Workspace? @relation("UserDefaultWorkspace", fields: [defaultWorkspaceId], references: [id], onDelete: SetNull)

  // Chat relations
  channelMemberships ChannelMember[]
  messages           Message[]
  reactions          MessageReaction[]
  savedMessages      SavedMessage[]
  messageReadStatus  MessageReadStatus[]

  // Wiki relations
  wikiPages          WikiPage[]
  wikiVersions       WikiVersion[]

  // File uploads
  uploadedFiles      File[]

  @@map("user")
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Active workspace context
  activeWorkspaceId String?
  activeWorkspace   Workspace? @relation(fields: [activeWorkspaceId], references: [id], onDelete: SetNull)

  // Admin plugin field for impersonation
  impersonatedBy String?

  @@unique([token])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@map("account")
}

model Verification {
  id         String   @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @default(now()) @updatedAt

  @@map("verification")
}

// Workspace model for multi-tenancy
model Workspace {
  id          String   @id @default(cuid())
  name        String
  slug        String   @unique
  image       String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  members     WorkspaceMember[]
  invitations WorkspaceInvitation[]
  sessions    Session[]
  defaultForUsers User[] @relation("UserDefaultWorkspace")
  channels    Channel[]
  wikiPages   WikiPage[]
  wikiTags    WikiTag[]
  files       File[]

  // Storage quota (in bytes)
  storageQuota     BigInt @default(5368709120) // 5GB default
  storageUsed      BigInt @default(0)

  @@map("workspace")
}

// Junction table for user-workspace relationship
model WorkspaceMember {
  id          String   @id @default(cuid())
  role        Role     @default(MEMBER)
  joinedAt    DateTime @default(now())

  // Relations
  userId      String
  workspaceId String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  workspace   Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@unique([userId, workspaceId])
  @@index([workspaceId])
  @@index([userId])
  @@map("workspace_member")
}

// Workspace invitation model
model WorkspaceInvitation {
  id          String   @id @default(cuid())
  email       String
  role        Role     @default(MEMBER)
  token       String   @unique @default(cuid())
  expiresAt   DateTime
  acceptedAt  DateTime?
  createdAt   DateTime @default(now())

  // Relations
  workspaceId String
  invitedById String
  workspace   Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  invitedBy   User      @relation(fields: [invitedById], references: [id])

  @@index([email])
  @@index([workspaceId])
  @@map("workspace_invitation")
}

// Role enum for workspace members
enum Role {
  OWNER
  ADMIN
  MEMBER
  VIEWER
}

// User role enum for application-wide permissions
enum UserRole {
  user
  admin
}

// User account status enum
enum UserStatus {
  ACTIVE
  SUSPENDED
  DELETED
}

// Chat & Wiki Models

model Channel {
  id          String    @id @default(cuid())
  name        String
  description String?
  category    String?     // For custom grouping
  type        ChannelType @default(PUBLIC)
  archived    Boolean     @default(false)
  archivedAt  DateTime?
  workspaceId String
  workspace   Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  members     ChannelMember[]
  messages    Message[]

  @@index([workspaceId])
  @@map("channel")
}

model ChannelMember {
  id        String      @id @default(cuid())
  channelId String
  userId    String
  role      ChannelRole @default(MEMBER)
  joinedAt  DateTime    @default(now())

  channel   Channel     @relation(fields: [channelId], references: [id], onDelete: Cascade)
  user      User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([channelId, userId])
  @@index([userId])
  @@map("channel_member")
}

model Message {
  id          String      @id @default(cuid())
  content     String
  type        MessageType @default(TEXT)
  attachments Json?       // Store attachment metadata (url, name, size, type, key)
  channelId   String
  userId      String
  threadId    String?     // For threading support
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  isEdited    Boolean     @default(false)
  isPinned    Boolean     @default(false)

  channel     Channel     @relation(fields: [channelId], references: [id], onDelete: Cascade)
  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  parent      Message?    @relation("Thread", fields: [threadId], references: [id], onDelete: SetNull)
  replies     Message[]   @relation("Thread")
  reactions   MessageReaction[]
  savedBy     SavedMessage[]
  readStatus  MessageReadStatus[]
  
  // Relationship to WikiPage conversion
  wikiPage    WikiPage?

  @@index([channelId])
  @@index([userId])
  @@index([threadId])
  @@map("message")
}

model MessageReaction {
  id        String   @id @default(cuid())
  messageId String
  userId    String
  emoji     String   // The emoji character(s)
  createdAt DateTime @default(now())

  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId, emoji]) // Prevent duplicate reactions
  @@index([messageId])
  @@index([userId])
  @@map("message_reaction")
}

model SavedMessage {
  id        String   @id @default(cuid())
  messageId String
  userId    String
  note      String?  // Optional note about why saved
  createdAt DateTime @default(now())

  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId])
  @@index([userId])
  @@index([messageId])
  @@map("saved_message")
}

model MessageReadStatus {
  id           String   @id @default(cuid())
  messageId    String
  userId       String
  readAt       DateTime @default(now())
  markedUnread Boolean  @default(false)

  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId])
  @@index([userId])
  @@index([messageId])
  @@map("message_read_status")
}


// Wiki Models

model WikiPage {
  id          String   @id @default(cuid())
  title       String
  slug        String   // URL-friendly identifier
  content     String   @db.Text // Markdown content
  excerpt     String?  // Short description
  
  // Source tracking
  messageId   String?  @unique // Source message if converted from chat
  message     Message? @relation(fields: [messageId], references: [id], onDelete: SetNull)
  
  // Workspace and user
  workspaceId String
  workspace   Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  authorId    String
  author      User      @relation(fields: [authorId], references: [id], onDelete: Cascade)
  
  // Nested pages support (tree structure)
  parentId    String?
  parent      WikiPage?   @relation("WikiPageNesting", fields: [parentId], references: [id], onDelete: SetNull)
  children    WikiPage[]  @relation("WikiPageNesting")
  
  // Metadata
  published   Boolean   @default(false)
  viewCount   Int       @default(0)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  publishedAt DateTime?
  
  // Relations
  versions    WikiVersion[]
  tags        WikiPageTag[]
  
  @@unique([workspaceId, slug])
  @@index([workspaceId])
  @@index([authorId])
  @@index([parentId])
  @@index([messageId])
  @@map("wiki_page")
}

model WikiVersion {
  id        String   @id @default(cuid())
  
  // Content snapshot
  title     String
  content   String   @db.Text
  excerpt   String?
  
  // Version metadata
  changeNote String? // Description of what changed
  version   Int      // Sequential version number
  
  // Relations
  pageId    String
  page      WikiPage @relation(fields: [pageId], references: [id], onDelete: Cascade)
  authorId  String
  author    User     @relation(fields: [authorId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())
  
  @@index([pageId])
  @@index([authorId])
  @@map("wiki_version")
}

model WikiTag {
  id          String   @id @default(cuid())
  name        String
  slug        String
  color       String?  // Hex color for UI display
  
  workspaceId String
  workspace   Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  
  pages       WikiPageTag[]
  
  createdAt   DateTime @default(now())
  
  @@unique([workspaceId, slug])
  @@index([workspaceId])
  @@map("wiki_tag")
}

// Junction table for WikiPage and WikiTag many-to-many relationship
model WikiPageTag {
  id     String   @id @default(cuid())
  
  pageId String
  page   WikiPage @relation(fields: [pageId], references: [id], onDelete: Cascade)
  
  tagId  String
  tag    WikiTag  @relation(fields: [tagId], references: [id], onDelete: Cascade)
  
  @@unique([pageId, tagId])
  @@index([pageId])
  @@index([tagId])
  @@map("wiki_page_tag")
}

// File Storage Model

model File {
  id          String   @id @default(cuid())
  name        String   // Original filename
  sanitizedName String // Sanitized filename
  key         String   @unique // Storage key (S3/R2)
  url         String   // Primary URL (UploadThing)
  backupUrl   String?  // Backup URL (AWS S3/R2)
  thumbnailUrl String? // Thumbnail URL if applicable
  mimeType    String
  size        Int      // Size in bytes
  
  // Image-specific metadata
  width       Int?
  height      Int?
  
  // Security
  virusScanned Boolean  @default(false)
  virusScanResult String? // CLEAN, INFECTED, PENDING, ERROR
  virusScanProvider String? // clamav, virustotal, disabled
  
  // Relations
  workspaceId String
  workspace   Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  uploadedById String
  uploadedBy  User     @relation(fields: [uploadedById], references: [id], onDelete: Cascade)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([workspaceId])
  @@index([uploadedById])
  @@index([key])
  @@map("file")
}


enum ChannelType {
  PUBLIC
  PRIVATE
  DM
}

enum ChannelRole {
  OWNER
  ADMIN
  MEMBER
}

enum MessageType {
  TEXT
  IMAGE
  FILE
  SYSTEM
}
